<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë„í˜• í•©ì¹˜ê¸° ê²Œì„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        :root{ --app-h: 100vh; }

        html, body {
            height: 100%;
        }
        
        body {
            font-family: 'Jua', sans-serif;
            background: linear-gradient(180deg, #FFEAA7 0%, #FDCB6E 50%, #F8B739 100%);
            min-height: var(--app-h);
            display: flex;
            /* Center the whole app horizontally on mobile (avoid one-sided gutters) */
            justify-content: center;
            /* Keep content pinned to the top so tall layouts don't clip */
            align-items: flex-start;
            user-select: none;
            /* Keep the full play area visible on mobile (avoid bottom clipping) */
            overflow: hidden;
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
        
            overscroll-behavior: none;
            -webkit-overflow-scrolling: auto;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            padding: 6px;
            /* Fit the whole UI inside the visual viewport on mobile (respect safe-areas) */
            min-height: calc(var(--app-h) - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
            height: calc(var(--app-h) - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
            max-height: calc(var(--app-h) - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
            overflow: hidden;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            flex-shrink: 0;
        }
        
        .score-section {
            text-align: center;
        }
        
        .score {
            font-size: 32px;
            color: #D63031;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff;
        }
        
        .controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .btn {
            width: 38px;
            height: 38px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(180deg, #FF7675 0%, #D63031 100%);
            box-shadow: 0 3px 0 #C0392B, 0 5px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: #fff;
            transition: transform 0.1s;
        }
        
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #C0392B;
        }
        
        .next-preview {
            background: linear-gradient(180deg, #74B9FF 0%, #0984E3 100%);
            padding: 5px 10px;
            border-radius: 16px;
            font-size: 10px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 3px 10px rgba(9,132,227,0.4);
            font-weight: bold;
        }
        
        .next-shape-container {
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .shake-btn {
            background: linear-gradient(180deg, #FDCB6E 0%, #F39C12 100%);
            box-shadow: 0 3px 0 #D68910, 0 5px 10px rgba(0,0,0,0.2);
            padding: 4px 8px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            font-family: 'Jua', sans-serif;
            transition: transform 0.1s;
        }
        
        .shake-btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #D68910;
        }
        
        .shake-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .shake-btn .cup-icon {
            font-size: 16px;
        }
        
        .shake-btn .shake-text {
            font-size: 8px;
            color: #5D4037;
            white-space: nowrap;
        }
        
        .shape-progression {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px 6px;
            background: rgba(255,255,255,0.85);
            border-radius: 14px;
            margin-bottom: 4px;
            flex-shrink: 0;
            gap: 2px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            flex-wrap: nowrap;
            overflow: hidden;
        }
        
        .prog-shape {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .prog-arrow {
            color: #E17055;
            font-size: 10px;
            flex-shrink: 0;
            margin: 0 1px;
            font-weight: bold;
        }
        
        .game-area-wrapper {
            position: relative;
            overflow: visible;
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
        }
        
        .drop-area {
            height: 42px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .current-shape {
            position: absolute;
            top: 5px;
            left: 0;
            z-index: 20;
            pointer-events: none;
            transition: none;
            /* transform ê¸°ë°˜ ì´ë™(ë ˆì´ì•„ì›ƒ ë¦¬í”Œë¡œìš° ìµœì†Œí™”) */
            transform: translate3d(0px,0,0) translateX(-50%);
            will-change: transform;
            contain: layout paint;
        }
        
        .drop-zone-touch {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            touch-action: none;
            z-index: 10;
        }
        
        .game-area {
            position: relative;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.25) 0%, 
                rgba(255,255,255,0.4) 50%,
                rgba(255,255,255,0.55) 100%
            );
            border-radius: 8px 8px 50% 50% / 8px 8px 40% 40%;
            border: 4px solid rgba(180, 160, 140, 0.6);
            border-top: none;
            /* Use remaining space (prevents bottom from being cut off on mobile) */
            height: auto;
            flex: 1 1 auto;
            min-height: 275px;
            overflow: hidden;
            box-shadow: 
                inset 0 0 60px rgba(255,255,255,0.4),
                inset -8px 0 20px rgba(255,255,255,0.3),
                inset 8px 0 20px rgba(200,180,160,0.15),
                0 20px 50px rgba(0,0,0,0.15);
            backdrop-filter: blur(2px);
        }
        
        .game-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 8px;
            width: 25%;
            bottom: 20px;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.2) 0%, 
                transparent 100%
            );
            pointer-events: none;
        }
        
        .game-area.shaking {
            animation: shake 0.4s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px) rotate(-1deg); }
            40% { transform: translateX(8px) rotate(1deg); }
            60% { transform: translateX(-6px) rotate(-0.5deg); }
            80% { transform: translateX(6px) rotate(0.5deg); }
        }
        
        .danger-line {
            position: absolute;
            top: 35px;
            left: 8px;
            right: 8px;
            height: 2px;
            background: repeating-linear-gradient(
                90deg,
                #FF6B6B 0px,
                #FF6B6B 6px,
                transparent 6px,
                transparent 12px
            );
            opacity: 0.6;
            border-radius: 1px;
            z-index: 5;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            border-radius: 8px 8px 50% 50% / 8px 8px 40% 40%;
        }
        
        .game-over-overlay.show {
            display: flex;
        }
        
        .game-over-text {
            font-size: 32px;
            color: #FFEAA7;
            text-shadow: 3px 3px 0 #D63031;
            margin-bottom: 12px;
            animation: bounce 0.5s ease infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-8px); }
        }
        
        .restart-btn {
            padding: 12px 35px;
            font-size: 18px;
            font-family: 'Jua', sans-serif;
            background: linear-gradient(180deg, #00B894 0%, #00A085 100%);
            border: none;
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 4px 0 #00806B, 0 6px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        
        .restart-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #00806B;
        }
        
        .combo-text {
            position: absolute;
            font-size: 26px;
            color: #E17055;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
            pointer-events: none;
            animation: comboFloat 1.2s ease-out forwards;
            z-index: 200;
            font-weight: bold;
            white-space: nowrap;
        }
        
        @keyframes comboFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            50% { transform: translateY(-40px) scale(1.3); }
            100% { opacity: 0; transform: translateY(-80px) scale(1); }
        }
        
        .combo-burst {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            animation: burstAnim 0.5s ease-out forwards;
        }
        
        @keyframes burstAnim {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        .overflow-warning {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.85);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 60;
            display: none;
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        

        /* Auto-drop warning (after 3s idle, shows 3-2-1 then drops) */
        .autodrop-warning{
            position: absolute;
            top: 62px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 80;
            display: none;
            align-items: center;
            gap: 10px;
            padding: 8px 14px;
            border-radius: 16px;
            background: rgba(0,0,0,0.55);
            color: #fff;
            box-shadow: 0 8px 22px rgba(0,0,0,0.22);
            backdrop-filter: blur(2px);
            pointer-events: none;
        }
        .autodrop-warning.show{ display:flex; }
        .autodrop-warning .count{
            font-size: 18px;
            font-weight: 900;
            color: #FFEAA7;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.25);
            min-width: 18px;
            text-align: right;
        }

        .music-btn {
            background: linear-gradient(180deg, #A29BFE 0%, #6C5CE7 100%) !important;
            box-shadow: 0 3px 0 #5B4ACF, 0 5px 10px rgba(0,0,0,0.2) !important;
        }
        
        .music-btn:active {
            box-shadow: 0 1px 0 #5B4ACF !important;
        }
        
        .game-container:fullscreen,
        .game-container:-webkit-full-screen {
            max-width: 420px;
            padding: 10px;
            background: linear-gradient(180deg, #FFEAA7 0%, #FDCB6E 50%, #F8B739 100%);
            /* Fullscreen on mobile can clip with 100vh/centering; use measured viewport height and top-align */
            min-height: var(--app-h);
            height: var(--app-h);
            overflow-y: auto;
            justify-content: flex-start;
            padding-top: calc(10px + env(safe-area-inset-top, 0px));
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        }
        
        .game-container:fullscreen .game-area,
        .game-container:-webkit-full-screen .game-area {
            /* Keep the bowl fully visible in fullscreen (avoid top/bottom clipping) */
            height: clamp(320px, calc(var(--app-h) - 320px), 480px);
        }

        /* Online overlay (matching / result) */
        .net-overlay{
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 120;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(2px);
            border-radius: 16px;
        }
        .net-overlay.show{ display:flex; }
        .net-overlay-card{
            width: 88%;
            max-width: 320px;
            background: rgba(255,255,255,0.92);
            border-radius: 18px;
            padding: 16px 14px;
            box-shadow: 0 10px 28px rgba(0,0,0,0.22);
            text-align: center;
        }
        .net-overlay-title{ font-size: 22px; color:#5D4037; margin-bottom: 6px; }
        .net-overlay-desc{ font-size: 14px; color:#6D4C41; margin-bottom: 10px; }
        .net-overlay-timer{ font-size: 14px; color:#D63031; font-weight: 900; margin-bottom: 12px; }
        .net-overlay-actions{ display:flex; gap:10px; justify-content:center; }
        .net-overlay-actions button{
            border: none;
            border-radius: 14px;
            padding: 10px 16px;
            font-family: 'Jua', sans-serif;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 3px 0 rgba(0,0,0,0.15), 0 6px 14px rgba(0,0,0,0.18);
        }
        .net-overlay-actions .retry{ background: linear-gradient(180deg, #FF7675 0%, #D63031 100%); color:#fff; }
        .net-overlay-actions .close{ background: rgba(255,255,255,0.9); color:#5D4037; }
    
        /* --- Online (Firebase) UI --- */
        .net-pill{
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            background: rgba(255,255,255,0.85);
            color: #5D4037;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            font-weight: bold;
            white-space: nowrap;
        }
        .net-btn{
            width: auto;
            padding: 0 10px;
            font-size: 12px;
        }
        .opp-panel{
            position: absolute;
            right: 10px;
            top: 10px;
            width: 176px;
            padding: 6px;
            border-radius: 14px;
            background: rgba(255,255,255,0.88);
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
            pointer-events: none;
        }
        .opp-title{
            font-size: 10px;
            color: #5D4037;
            font-weight: bold;
            margin-bottom: 4px;
            text-align: left;
        }
        #opp-canvas{
            width: 100%;
            height: 150px;
            border-radius: 10px;
            background: rgba(255,255,255,0.35);
        }

/* ===== Custom layout: match the provided screenshot (top-left stack + right opponent panel) ===== */
.header.header-layout{
    align-items: flex-start;
    gap: 14px;
}
.header-left{
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
}
.header-right{
    flex: 0 0 auto;
}

.controls-row{
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: nowrap;
}

/* ë§¤ì¹­ ë²„íŠ¼: ë¹¨ê°•(ê¸°ë³¸ .btn) + í…ìŠ¤íŠ¸ ë²„íŠ¼ í˜•íƒœ */
.match-btn{
    width: auto;
    min-width: 70px;
    padding: 0 14px;
    height: 42px;
    border-radius: 14px;
    font-size: 16px;
    font-weight: 800;
}

/* ì „ì²´í™”ë©´ ë²„íŠ¼: ë³´ë¼ */
.full-btn{
    width: 42px;
    height: 42px;
    border-radius: 12px;
    background: linear-gradient(180deg, #A29BFE 0%, #6C5CE7 100%) !important;
    box-shadow: 0 3px 0 #4E3FCF, 0 5px 10px rgba(0,0,0,0.2) !important;
}
.full-btn:active{
    box-shadow: 0 1px 0 #4E3FCF !important;
}

/* ìŒì•… ë²„íŠ¼ì€ ìˆ¨ê¹€(ê¸°ëŠ¥ í˜¸í™˜ìš© DOMë§Œ ìœ ì§€) */
.music-btn{ display: none !important; }

.score-section{ text-align: left; }
.score{ line-height: 1; }

/* NEXT + í”ë“¤ê¸° íŒ¨ë„ */
.control-panel{
    width: 100%;
    max-width: 240px;
    padding: 12px;
    border-radius: 18px;
    background: rgba(255,255,255,0.18);
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
}

.next-preview-large{
    padding: 10px 14px;
    border-radius: 18px;
    font-size: 14px;
    gap: 10px;
    min-height: 44px;
}
.next-preview-large .next-shape-container{
    width: 28px;
    height: 28px;
}

.shake-btn-large{
    margin-top: 10px;
    width: 100%;
    min-height: 54px;
    flex-direction: row;
    justify-content: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 18px;
}
.shake-btn-large .cup-icon{ font-size: 20px; }
.shake-btn-large .shake-text{ font-size: 14px; color: #fff; }

/* ìƒëŒ€ íŒ¨ë„: ê²Œì„ ì»µê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ í—¤ë” ìš°ì¸¡ì— ë°°ì¹˜ */
.header-right .opp-panel{
    position: relative !important;
    right: auto !important;
    top: auto !important;
    /* Slightly smaller so it aligns with the end of the left-side button block */
    width: 150px;
}

.header-right #opp-canvas{
    /* Keep the opponent preview compact on mobile */
    height: 150px;
}

@media (max-width: 420px){
    .header.header-layout{ flex-wrap: nowrap; }
    .header-right .opp-panel{ width: 145px; }
    .control-panel{ max-width: 210px; }
    .match-btn{ min-width: 62px; padding: 0 12px; }
}

@media (max-width: 360px){
    .header.header-layout{ flex-wrap: wrap; }
    .header-right{ width: 100%; }
}

    </style>
</head>
<body>
    <div class="game-container" id="game-container">
        
<div class="header header-layout">
    <div class="header-left">
        <div class="controls-row">
            <button class="btn net-btn match-btn" id="match-btn" title="ì˜¨ë¼ì¸ ë§¤ì¹­">ë§¤ì¹­</button>
            <div class="net-pill" id="net-status">ì˜¤í”„ë¼ì¸</div>
            <button class="btn full-btn" id="fullscreen-btn" title="ì „ì²´í™”ë©´">â›¶</button>
            <!-- ìŒì•… ë²„íŠ¼ì€ ê¸°ëŠ¥ í˜¸í™˜ì„ ìœ„í•´ DOMì— ë‚¨ê¸°ë˜ í™”ë©´ì—ì„œëŠ” ìˆ¨ê¹€ -->
            <button class="btn music-btn" id="music-btn" title="ìŒì•…" aria-hidden="true">ğŸ¶</button>
        </div>

        <div class="score-section">
            <div class="score" id="score">0</div>
        </div>

        <div class="control-panel">
            <div class="next-preview next-preview-large">
                <span>NEXT</span>
                <div class="next-shape-container" id="next-shape"></div>
            </div>

            <button class="shake-btn shake-btn-large" id="shake-btn" title="í”ë“¤ê¸°">
                <span class="cup-icon">ğŸ¥¤</span>
                <span class="shake-text">í”ë“¤ê¸° <span id="shake-count">X2</span></span>
            </button>
        </div>
    </div>

    <div class="header-right">
        <div class="opp-panel" id="opp-panel">
            <div class="opp-title" id="opp-title">ìƒëŒ€ (ì—°ê²° ëŒ€ê¸°â€¦)</div>
            <canvas id="opp-canvas" width="150" height="150"></canvas>
        </div>
    </div>
</div>

        <!-- Online overlay: matching / result (hidden by default; controlled by js/main.js) -->
        <div class="net-overlay" id="net-overlay" aria-hidden="true">
            <div class="net-overlay-card">
                <div class="net-overlay-title" id="net-overlay-title">ë§¤ì¹­ ì¤‘â€¦</div>
                <div class="net-overlay-desc" id="net-overlay-desc">ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤.</div>
                <div class="net-overlay-timer" id="net-overlay-timer"></div>
                <div class="net-overlay-actions">
                    <button class="retry" id="net-overlay-retry">ë‹¤ì‹œ ë§¤ì¹­</button>
                    <button class="close" id="net-overlay-close">ë‹«ê¸°</button>
                </div>
            </div>
        </div>
        <div class="shape-progression" id="shape-progression"></div>
        
        <div class="game-area-wrapper">
            <div class="drop-area" id="drop-area">
                <div class="drop-zone-touch" id="drop-zone"></div>
                <div class="current-shape" id="current-shape"></div>
            </div>
            <div class="autodrop-warning" id="autodrop-warning" aria-hidden="true">
                <span class="msg">ë„í˜•ì„ ë‹´ì•„ì£¼ì„¸ìš”!</span>
                <span class="count" id="autodrop-count">3</span>
            </div>

            <div class="game-area" id="game-area">
                <div class="danger-line"></div>
                <div class="overflow-warning" id="overflow-warning">âš ï¸ ë„˜ì¹œë‹¤!</div>
                <canvas id="game-canvas"></canvas>
                
                <div class="game-over-overlay" id="game-over">
                    <div class="game-over-text">ê²Œì„ ì˜¤ë²„!</div>
                    <div style="color: #fff; font-size: 22px; margin-bottom: 12px;">
                        ì ìˆ˜: <span id="final-score">0</span>
                    </div>
                    <button class="restart-btn" id="restart-btn">ë‹¤ì‹œ í•˜ê¸°</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const SHAPES = [
            { name: 'ì‘ì€ì›', type: 'circle', color: '#FF6B6B', size: 14 },
            { name: 'ì‚¼ê°í˜•', type: 'triangle', color: '#FECA57', size: 22 },
            { name: 'ì´ë“±ë³€ì‚¼ê°í˜•', type: 'isoceles', color: '#48DBFB', size: 31 },
            { name: 'ì‚¬ê°í˜•', type: 'square', color: '#1DD1A1', size: 41 },
            { name: 'ì§ì‚¬ê°í˜•', type: 'rectangle', color: '#5F27CD', size: 53 },
            { name: 'ë§ˆë¦„ëª¨', type: 'diamond', color: '#FF9FF3', size: 67 },
            { name: 'ì˜¤ê°í˜•', type: 'pentagon', color: '#54A0FF', size: 84 },
            { name: 'ìœ¡ê°í˜•', type: 'hexagon', color: '#00D2D3', size: 103 },
            { name: 'í°ì›', type: 'bigcircle', color: '#FF9F43', size: 105 }
        ];

        const EXPRESSIONS = {
            NORMAL: 'normal',
            HAPPY: 'happy',
            SURPRISED: 'surprised',
            WORRIED: 'worried',
            EXCITED: 'excited'
        };

        // Expose shape meta for online opponent rendering (js/main.js)
        window.SHAPES = SHAPES;

        // Fix mobile viewport clipping (100vh address-bar issues)
        function __setAppHeight(){
            try{
                const vv = window.visualViewport;
                const h = (vv && typeof vv.height === 'number') ? vv.height : window.innerHeight;
                document.documentElement.style.setProperty('--app-h', Math.round(h) + 'px');
            }catch(e){}
        }
        __setAppHeight();
        window.addEventListener('resize', __setAppHeight);
        window.addEventListener('orientationchange', __setAppHeight);
        if(window.visualViewport){
            window.visualViewport.addEventListener('resize', __setAppHeight);
            window.visualViewport.addEventListener('scroll', __setAppHeight);
        }
        document.addEventListener('fullscreenchange', __setAppHeight);
        document.addEventListener('webkitfullscreenchange', __setAppHeight);

        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
                this.musicPlaying = false;
                this.musicInterval = null;
                this.musicGain = null;
            }

            init() {
                if (this.initialized) return true;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.connect(this.audioContext.destination);
                    this.musicGain.gain.value = 0.12;
                    this.initialized = true;
                    return true;
                } catch(e) { return false; }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') this.audioContext.resume();
            }

            playTone(freq, dur, type = 'sine', vol = 0.3, dest = null) {
                if (!this.audioContext || !this.initialized) return;
                try {
                    this.resume();
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(dest || this.audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = type;
                    const now = this.audioContext.currentTime;
                    gain.gain.setValueAtTime(vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + dur);
                    osc.start(now);
                    osc.stop(now + dur);
                } catch(e) {}
            }

            startMusic() {
                if (!this.initialized || this.musicPlaying) return;
                this.resume();
                this.musicPlaying = true;

                // ëª¨ë°”ì¼ì—ì„œ ë“œë¬¸ë“œë¬¸ ëŠê¸°ëŠ” í˜„ìƒ(ë©”ì¸ìŠ¤ë ˆë“œ ë¶€í•˜/GC)ì„ ì¤„ì´ê¸° ìœ„í•´
                // ë°°ê²½ìŒì€ "ë…¸ë“œ ì¬ìƒì„±" ëŒ€ì‹  ì¬ì‚¬ìš© ë…¸ë“œ + ë¯¸ë¦¬ ìŠ¤ì¼€ì¤„ë§ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
                const dest = this.musicGain || this.audioContext.destination;

                if (!this._music) {
                    const o1 = this.audioContext.createOscillator();
                    const g1 = this.audioContext.createGain();
                    o1.type = 'sine';
                    g1.gain.value = 0.0001;
                    o1.connect(g1);
                    g1.connect(dest);

                    const o2 = this.audioContext.createOscillator();
                    const g2 = this.audioContext.createGain();
                    o2.type = 'triangle';
                    g2.gain.value = 0.0001;
                    o2.connect(g2);
                    g2.connect(dest);

                    try { o1.start(); } catch(e) {}
                    try { o2.start(); } catch(e) {}

                    this._music = { o1, g1, o2, g2, nextTime: this.audioContext.currentTime + 0.06, idx: 0 };
                }

                const melody = [523, 587, 659, 587, 523, 659, 587, 523, 659, 698, 784, 698, 659, 587, 523, 587];
                const step = 0.28;           // í•œ ìŒ ê°„ê²©(ì´ˆ)
                const ahead = 1.2;           // ë¯¸ë¦¬ ìŠ¤ì¼€ì¤„(ì´ˆ)
                const envDur = 0.22;

                const schedule = () => {
                    if (!this.musicPlaying || !this._music) return;
                    const m = this._music;
                    const now = this.audioContext.currentTime;

                    while (m.nextTime < now + ahead) {
                        const f = melody[m.idx];

                        // main voice
                        try {
                            m.o1.frequency.setValueAtTime(f, m.nextTime);
                            m.g1.gain.cancelScheduledValues(m.nextTime);
                            m.g1.gain.setValueAtTime(0.0001, m.nextTime);
                            m.g1.gain.linearRampToValueAtTime(0.085, m.nextTime + 0.01);
                            m.g1.gain.exponentialRampToValueAtTime(0.0001, m.nextTime + envDur);
                        } catch(e) {}

                        // accent (every 4)
                        if (m.idx % 4 === 0) {
                            try {
                                m.o2.frequency.setValueAtTime(f * 1.25, m.nextTime);
                                m.g2.gain.cancelScheduledValues(m.nextTime);
                                m.g2.gain.setValueAtTime(0.0001, m.nextTime);
                                m.g2.gain.linearRampToValueAtTime(0.045, m.nextTime + 0.01);
                                m.g2.gain.exponentialRampToValueAtTime(0.0001, m.nextTime + envDur);
                            } catch(e) {}
                        }

                        m.idx = (m.idx + 1) % melody.length;
                        m.nextTime += step;
                    }
                };

                schedule();
                this.musicInterval = setInterval(schedule, 400);
            }

            stopMusic() {
                this.musicPlaying = false;
                if (this.musicInterval) { clearInterval(this.musicInterval); this.musicInterval = null; }
                // ì¬ì‚¬ìš© ì˜¤ì‹¤ë ˆì´í„°ëŠ” ìœ ì§€í•˜ë˜, ê²Œì¸ì„ 0ì— ê°€ê¹ê²Œ ë‚´ë ¤ CPU/í´ë¦­ ì¡ìŒ ìµœì†Œí™”
                if (this._music) {
                    try {
                        const t = this.audioContext.currentTime;
                        this._music.g1.gain.cancelScheduledValues(t);
                        this._music.g2.gain.cancelScheduledValues(t);
                        this._music.g1.gain.setValueAtTime(0.0001, t);
                        this._music.g2.gain.setValueAtTime(0.0001, t);
                        this._music.nextTime = t + 0.06;
                    } catch(e) {}
                }
            }

            toggleMusic() { if (this.musicPlaying) { this.stopMusic(); return false; } else { this.startMusic(); return true; } }
            playDrop() { this.playTone(880, 0.08, 'sine', 0.2); setTimeout(() => this.playTone(660, 0.06, 'sine', 0.15), 40); }
            playLand() { this.playTone(180, 0.1, 'sine', 0.2); setTimeout(() => this.playTone(120, 0.12, 'triangle', 0.12), 40); }
            playMerge(lvl) { const f = 400 + lvl * 80; this.playTone(f, 0.1, 'sine', 0.25); setTimeout(() => this.playTone(f * 1.25, 0.1, 'sine', 0.2), 50); setTimeout(() => this.playTone(f * 1.5, 0.12, 'sine', 0.15), 100); }
            playCombo(cnt) { const f = 500 + cnt * 100; for (let i = 0; i < 3; i++) setTimeout(() => this.playTone(f + i * 150, 0.08, 'square', 0.1), i * 40); }
            playShake() { for (let i = 0; i < 5; i++) setTimeout(() => this.playTone(200 + Math.random() * 100, 0.05, 'triangle', 0.15), i * 60); }
            playGameOver() { this.stopMusic(); [400, 350, 300, 200].forEach((f, i) => setTimeout(() => this.playTone(f, 0.25, 'sawtooth', 0.15), i * 120)); }
        }

        class ShapeGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameArea = document.getElementById('game-area');
                this.wrapper = document.querySelector('.game-area-wrapper');
                this.sound = new SoundSystem();

                // --- Fixed logical world size (ê¸°ê¸°/ì „ì²´í™”ë©´ì´ ë‹¬ë¼ë„ ê°™ì€ í™”ë©´/ë¬¼ë¦¬) ---
                this.worldW = 360;
                this.worldH = 560;
                // physics ê¸°ì¤€ í¬ê¸°
                this.width = this.worldW;
                this.height = this.worldH;
                // view(ìº”ë²„ìŠ¤) ë³€í™˜ ì •ë³´
                this.view = { cssW: 0, cssH: 0, dpr: 1, scale: 1, ox: 0, oy: 0 };
                // danger line is in world coordinates
                this.dangerYWorld = Math.max(40, this.worldH * 0.08);
                // drag mapping cache (drop-zone -> world)
                this._dropMap = { rect: null, s: 1, ox: 0, left: 0, w: 1 };

                this.score = 0;
                this.currentShapeIndex = 0;
                this.nextShapeIndex = 0;
                this.isGameOver = false;
                this.canDrop = true;
                this.dropX = 0;
                this.bodies = [];
                this.blinkTimers = new Map();
                this.expressionTimers = new Map();
                this.overflowFrames = new Map();
                this.comboCount = 0;
                this.lastMergeTime = 0;
                this.shakeRemaining = 2;
                this.soundInitialized = false;
                this.musicEnabled = true; // ê¸°ë³¸: ìŒì•… ON (ìŒì•… ë²„íŠ¼ì„ ëˆ„ë¥´ì§€ ì•Šì•„ë„ ìë™ ì¬ìƒ)
                this.mergingPairs = new Set();
                // Online hooks
                this.onComboEnd = null;
                this.onGameOver = null;
                this.onRestart = null;
                this._comboSeq = 0;

                // Auto-drop (idle->warning 3-2-1 -> drop)
                this._spawnTs = Date.now();
                this._autoWarnActive = false;
                this._autoCountdown = 0;
                this._autoTimer = null;
                this.autoWarnEl = null;
                this.autoCountEl = null;
                
                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupPhysics();
                this.setupEvents();
                // Auto-drop UI elements
                this.autoWarnEl = document.getElementById('autodrop-warning');
                this.autoCountEl = document.getElementById('autodrop-count');
                this.createShapeProgression();
                this.generateNextShape();
                this.generateNextShape();
                this.updateUI();
                this.updateShakeButton();
                this.gameLoop();
            }

            initSoundOnInteraction() {
                if (!this.soundInitialized) {
                    this.soundInitialized = this.sound.init();
                }
                this.sound.resume();

                // ê¸°ë³¸ì€ ìŒì•… ON: ìŒì•… ë²„íŠ¼ì„ ëˆ„ë¥´ì§€ ì•Šì•„ë„ ì²« ìƒí˜¸ì‘ìš©(í„°ì¹˜/í´ë¦­) ì‹œ ìë™ ì¬ìƒ
                if (this.musicEnabled && !this.isGameOver && !this.sound.musicPlaying) {
                    this.sound.startMusic();
                }

                const musicBtn = document.getElementById('music-btn');
                if (musicBtn) musicBtn.textContent = (this.musicEnabled && this.sound.musicPlaying) ? 'ğŸ¶' : 'ğŸµ';
            }

            setupCanvas() {
                // game-area ë†’ì´ë¥¼ "ê³ ì • ë¹„ìœ¨"ë¡œ ë§ì¶°, ê¸°ê¸°/ì „ì²´í™”ë©´ì—ì„œë„ ê·¸ë¦‡ ê¹Šì´ê°€ ë‹¬ë¼ì§€ì§€ ì•Šê²Œ í•¨
                try {
                    const dropArea = document.getElementById('drop-area');
                    const wrapRect = this.wrapper ? this.wrapper.getBoundingClientRect() : null;
                    const dropH = dropArea ? dropArea.getBoundingClientRect().height : 0;
                    const maxH = wrapRect ? Math.max(260, wrapRect.height - dropH - 10) : null;

                    const w = this.gameArea.getBoundingClientRect().width;
                    const desiredH = w * (this.worldH / this.worldW);
                    const finalH = maxH ? Math.min(desiredH, maxH) : desiredH;

                    this.gameArea.style.height = Math.round(finalH) + 'px';
                } catch(e) {}

                const rect = this.gameArea.getBoundingClientRect();
                const cssW = rect.width;
                const cssH = rect.height;

                const dpr = Math.min(2, window.devicePixelRatio || 1);
                this.canvas.style.width = cssW + 'px';
                this.canvas.style.height = cssH + 'px';
                this.canvas.width = Math.max(1, Math.floor(cssW * dpr));
                this.canvas.height = Math.max(1, Math.floor(cssH * dpr));

                this.view = this.view || { cssW: 0, cssH: 0, dpr: 1, scale: 1, ox: 0, oy: 0 };
                this.view.cssW = cssW;
                this.view.cssH = cssH;
                this.view.dpr = dpr;

                const scale = Math.min(cssW / this.worldW, cssH / this.worldH);
                this.view.scale = scale;
                this.view.ox = (cssW - this.worldW * scale) / 2;
                this.view.oy = (cssH - this.worldH * scale) / 2;

                if (!this.dropX) this.dropX = this.worldW / 2;
                this.updateDangerLine();
                this.updateCurrentShapeUI();
            }

            updateDangerLine() {
                const line = this.gameArea ? this.gameArea.querySelector('.danger-line') : null;
                this.dangerY = this.dangerYWorld;
                if (line && this.view) {
                    line.style.top = Math.round(this.view.oy + this.dangerYWorld * this.view.scale) + 'px';
                }
            }


            updateCurrentShapeUI() {
                const el = document.getElementById('current-shape');
                const dropArea = document.getElementById('drop-area');
                if (!el || !dropArea) return;

                const rect = dropArea.getBoundingClientRect();
                const w = Math.max(1, rect.width);
                const s = w / this.worldW;
                const ox = (w - this.worldW * s) / 2;

                const xPx = ox + this.dropX * s;
                el.style.transform = `translate3d(${xPx}px,0,0) translateX(-50%)`;
            }

            createShapeProgression() {
                const container = document.getElementById('shape-progression');
                container.innerHTML = '';
                SHAPES.forEach((shape, i) => {
                    const div = document.createElement('div');
                    div.className = 'prog-shape';
                    div.innerHTML = this.createProgressionShapeSVG(i, 18);
                    container.appendChild(div);
                    if (i < SHAPES.length - 1) {
                        const arrow = document.createElement('span');
                        arrow.className = 'prog-arrow';
                        arrow.textContent = 'â€º';
                        container.appendChild(arrow);
                    }
                });
            }

            createProgressionShapeSVG(index, size) {
                const shape = SHAPES[index];
                const vs = size * 1.3, cx = vs/2, cy = vs/2, r = size * 0.48;
                const es = 1.3, eg = size * 0.12;
                return `<svg width="${vs}" height="${vs}" viewBox="0 0 ${vs} ${vs}">
                    <path d="${this.getShapePath(shape.type, cx, cy, r)}" fill="${shape.color}" stroke="${this.darkenColor(shape.color, 15)}" stroke-width="1.2"/>
                    <circle cx="${cx - eg}" cy="${cy}" r="${es}" fill="#2C1810"/>
                    <circle cx="${cx + eg}" cy="${cy}" r="${es}" fill="#2C1810"/>
                </svg>`;
            }

            getShapePath(type, cx, cy, r) {
                switch(type) {
                    case 'circle': case 'bigcircle':
                        return `M ${cx} ${cy-r} A ${r} ${r} 0 1 1 ${cx} ${cy+r} A ${r} ${r} 0 1 1 ${cx} ${cy-r}`;
                    case 'triangle':
                        return [0,1,2].map(i => { const a=(i*120-90)*Math.PI/180; return `${i===0?'M':'L'} ${cx+r*Math.cos(a)},${cy+r*Math.sin(a)}`; }).join(' ')+'Z';
                    case 'isoceles':
                        return `M ${cx} ${cy-r*1.3} L ${cx+r*0.7} ${cy+r*0.7} L ${cx-r*0.7} ${cy+r*0.7} Z`;
                    case 'square':
                        return `M ${cx-r*0.8} ${cy-r*0.8} L ${cx+r*0.8} ${cy-r*0.8} L ${cx+r*0.8} ${cy+r*0.8} L ${cx-r*0.8} ${cy+r*0.8} Z`;
                    case 'rectangle':
                        return `M ${cx-r*1.1} ${cy-r*0.6} L ${cx+r*1.1} ${cy-r*0.6} L ${cx+r*1.1} ${cy+r*0.6} L ${cx-r*1.1} ${cy+r*0.6} Z`;
                    case 'diamond':
                        return `M ${cx} ${cy-r} L ${cx+r*0.75} ${cy} L ${cx} ${cy+r} L ${cx-r*0.75} ${cy} Z`;
                    case 'pentagon':
                        return [0,1,2,3,4].map(i => { const a=(i*72-90)*Math.PI/180; return `${i===0?'M':'L'} ${cx+r*Math.cos(a)},${cy+r*Math.sin(a)}`; }).join(' ')+'Z';
                    case 'hexagon':
                        return [0,1,2,3,4,5].map(i => { const a=(i*60-90)*Math.PI/180; return `${i===0?'M':'L'} ${cx+r*Math.cos(a)},${cy+r*Math.sin(a)}`; }).join(' ')+'Z';
                }
                return '';
            }

            setupPhysics() {
                // setupPhysics()ëŠ” restart/ë¦¬ì‚¬ì´ì¦ˆ íë¦„ì—ì„œ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œë  ìˆ˜ ìˆìŒ.
                // ì—”ì§„ì´ ìƒˆë¡œ ë§Œë“¤ì–´ì§ˆ ë•Œë§ˆë‹¤ collisionStart í•¸ë“¤ëŸ¬ë¥¼ í˜„ì¬ ì—”ì§„ì— ë‹¤ì‹œ ë°”ì¸ë”©í•´ì•¼
                // (ì˜¨ë¼ì¸ ë§¤ì¹­ ì‹œì‘ ì‹œ ìë™ restart í¬í•¨) í•©ì²´ê°€ ë©ˆì¶”ëŠ” ë²„ê·¸ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ.
                const prevEngine = this.engine;
                if (!this._onCollisionStart) {
                    this._onCollisionStart = (e) => {
                        e.pairs.forEach(pair => this.handleCollision(pair.bodyA, pair.bodyB));
                    };
                }
                if (prevEngine) {
                    try { Matter.Events.off(prevEngine, 'collisionStart', this._onCollisionStart); } catch(e) {}
                }

                this.engine = Matter.Engine.create({ positionIterations: 10, velocityIterations: 10 });
                this.world = this.engine.world;
                this.engine.world.gravity.y = 1.0;
                Matter.Events.on(this.engine, 'collisionStart', this._onCollisionStart);

                // í˜„ì¬ ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ì¶° ê·¸ë¦‡(ë°”ë‹¥/ë²½) ê²½ê³„ë¥¼ êµ¬ì„±
                this.rebuildBounds();
            }

            rebuildBounds() {
                if (!this.world) return;

                // ê¸°ì¡´ ì •ì  ë°”ë””(ë°”ë‹¥/ë²½) ì œê±° í›„ ì¬ìƒì„±: í™”ë©´ ë¦¬ì‚¬ì´ì¦ˆ/ì „ì²´í™”ë©´ì—ì„œë„ ë¬¼ë¦¬ ê²½ê³„ê°€ í•­ìƒ ì¼ì¹˜í•˜ë„ë¡
                const all = Matter.Composite.allBodies(this.world);
                for (const b of all) {
                    if (b.isStatic) {
                        try { Matter.Composite.remove(this.world, b); } catch(e) {}
                    }
                }

                const wallOpts = { isStatic: true, friction: 0.8, restitution: 0.1, label: 'wall' };

                // ê³¡ì„  ë°”ë‹¥(ì‹œê°ì  ì»µ ê³¡ì„ ê³¼ ë§ì¶”ê¸°)
                // - bottomYê°€ ë„ˆë¬´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©´ ë„í˜•ì´ í™”ë©´ ì•„ë˜ë¡œ ë„˜ì–´ê°€ë©° "ê²½ê³„ ë¶ˆì¼ì¹˜"ê°€ ë°œìƒí•˜ë¯€ë¡œ ë†’ì´ë¥¼ ì˜¬ë¦¼
                const w = this.worldW;
                const h = this.worldH;

                // ê³¡ì„  ë°”ë‹¥(ë¬¼ë¦¬ ê·¸ë¦‡)ì€ "ì›”ë“œ ì¢Œí‘œ" ê¸°ì¤€ìœ¼ë¡œ ê³ ì •
                // - bottomYëŠ” ì›”ë“œ ì•ˆìª½(h-2)ìœ¼ë¡œ ë‘ì–´ ì•„ë˜ë¡œ ì‚´ì§ ë„˜ì–´ê°€ëŠ” í˜„ìƒ/ìƒëŒ€í™”ë©´ ë°”ë‹¥ ì˜ë¦¼ì„ ë°©ì§€
                const bottomY = h - 2;
                const curveTopY = h * 0.6; // ê³¡ì„  ì‹œì‘ì (ë¹„ìœ¨ ê³ ì •)
                const curveDepth = bottomY - curveTopY;

                const centerX = w / 2;
                const radiusX = w / 2 - 8;
                const radiusY = curveDepth;
                // Uìí˜• ê³¡ì„  ë°”ë‹¥
                const segments = 24;
                for (let i = 0; i < segments; i++) {
                    const angle1 = Math.PI - (i / segments) * Math.PI;
                    const angle2 = Math.PI - ((i + 1) / segments) * Math.PI;

                    const x1 = centerX + radiusX * Math.cos(angle1);
                    const y1 = curveTopY + radiusY * Math.sin(angle1);
                    const x2 = centerX + radiusX * Math.cos(angle2);
                    const y2 = curveTopY + radiusY * Math.sin(angle2);

                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2) + 4;

                    Matter.Composite.add(this.world, Matter.Bodies.rectangle(
                        midX, midY, len, 20,
                        { ...wallOpts, angle: angle, label: 'floor' }
                    ));
                }

                // ì¢Œìš° ë²½
                Matter.Composite.add(this.world, Matter.Bodies.rectangle(
                    -12, curveTopY / 2, 30, curveTopY + 20, wallOpts
                ));
                Matter.Composite.add(this.world, Matter.Bodies.rectangle(
                    w + 12, curveTopY / 2, 30, curveTopY + 20, wallOpts
                ));
            }

            setupEvents() {
                const dropZone = document.getElementById('drop-zone');
                const restartBtn = document.getElementById('restart-btn');
                const shakeBtn = document.getElementById('shake-btn');
                const musicBtn = document.getElementById('music-btn');
                const fullBtn = document.getElementById('fullscreen-btn');
                const gameContainer = document.getElementById('game-container');

                if (dropZone) dropZone.style.touchAction = 'none';

                if (restartBtn) restartBtn.addEventListener('click', () => this.restart());
                if (shakeBtn) shakeBtn.addEventListener('click', () => this.shakeCup && this.shakeCup());
                if (musicBtn) musicBtn.addEventListener('click', () => {
                    this.initSoundOnInteraction();
                    this.musicEnabled = this.sound.toggleMusic();
                    musicBtn.textContent = this.musicEnabled ? 'ğŸ¶' : 'ğŸµ';
                });

                // Fullscreen
                if (fullBtn && gameContainer) {
                    fullBtn.addEventListener('click', async () => {
                        try {
                            if (!document.fullscreenElement) await gameContainer.requestFullscreen();
                            else await document.exitFullscreen();
                        } catch(e) {}
                        setTimeout(() => this.setupCanvas(), 80);
                    });
                }

                // Pointer controls (drag to move, release to drop)
                let dragging = false;
                let activeId = null;

                const refreshMap = () => {
                    if (!dropZone) return;
                    const r = dropZone.getBoundingClientRect();
                    const w = Math.max(1, r.width);
                    const s = w / this.worldW;
                    const ox = (w - this.worldW * s) / 2;
                    this._dropMap = { left: r.left, w, s, ox };
                };

                const onMoveClientX = (clientX) => {
                    // dropZoneê°€ ìŠ¤í¬ë¡¤/ì£¼ì†Œì°½ ë³€í™”ë¡œ ì›€ì§ì˜€ì„ ìˆ˜ ìˆì–´, ë“œë˜ê·¸ ì‹œì‘/ë¦¬ì‚¬ì´ì¦ˆ ë•Œë§Œ ë§µ ê°±ì‹ 
                    this.updateDropPosition(clientX);
                };

                const moveHandler = (e) => {
                    if (!dragging || e.pointerId !== activeId) return;
                    if (e.cancelable) e.preventDefault();
                    const evs = (typeof e.getCoalescedEvents === 'function') ? e.getCoalescedEvents() : null;
                    const last = (evs && evs.length) ? evs[evs.length - 1] : e;
                    onMoveClientX(last.clientX);
                };

                if (dropZone) {
                    dropZone.addEventListener('pointerdown', (e) => {
                        if (e.cancelable) e.preventDefault();
                        this.initSoundOnInteraction();
                        dragging = true;
                        activeId = e.pointerId;
                        try { dropZone.setPointerCapture(e.pointerId); } catch(err) {}
                        refreshMap();
                        onMoveClientX(e.clientX);
                    }, { passive: false });

                    dropZone.addEventListener('pointermove', moveHandler, { passive: false });
                    // Chrome/Android: ë” ì´˜ì´˜í•œ ì—…ë°ì´íŠ¸(ê°€ëŠ¥í•  ë•Œë§Œ)
                    dropZone.addEventListener('pointerrawupdate', moveHandler, { passive: false });

                    dropZone.addEventListener('pointerup', (e) => {
                        if (e.pointerId !== activeId) return;
                        if (e.cancelable) e.preventDefault();
                        dragging = false;
                        activeId = null;
                        try { dropZone.releasePointerCapture(e.pointerId); } catch(err) {}
                        this.dropShape();
                    }, { passive: false });

                    dropZone.addEventListener('pointercancel', (e) => {
                        if (e.pointerId !== activeId) return;
                        dragging = false;
                        activeId = null;
                        try { dropZone.releasePointerCapture(e.pointerId); } catch(err) {}
                    }, { passive: true });
                }

                // Keyboard: Space to drop (force)
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.key === ' ') {
                        if (e.cancelable) e.preventDefault();
                        this.dropShape(true);
                    }
                }, { passive: false });

                // Resize / viewport changes -> only rescale view (world is fixed)
                const onResize = () => {
                    this._dropMap = { rect: null, s: 1, ox: 0, left: 0, w: 1 };
                    setTimeout(() => this.setupCanvas(), 80);
                };
                window.addEventListener('resize', onResize);
                window.addEventListener('orientationchange', onResize);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', onResize);
                    window.visualViewport.addEventListener('scroll', onResize);
                }
                document.addEventListener('fullscreenchange', onResize);
                document.addEventListener('webkitfullscreenchange', onResize);
            }

            updateDropPosition(clientX) {
                // pointermoveë§ˆë‹¤ layout ì¸¡ì •(getBoundingClientRect)ì„ í•˜ì§€ ì•Šê³ ,
                // pointerdown ë•Œ ìºì‹œí•œ ë§µì„ ì‚¬ìš©í•´ ëŠê¹€/ì§€ì—°ì„ ì¤„ì„
                let m = this._dropMap;
                if (!m || !m.w) {
                    const dz = document.getElementById('drop-zone');
                    if (!dz) return;
                    const r = dz.getBoundingClientRect();
                    const w = Math.max(1, r.width);
                    const s = w / this.worldW;
                    const ox = (w - this.worldW * s) / 2;
                    this._dropMap = m = { left: r.left, w, s, ox };
                }

                const localX = clientX - m.left;
                const x = (localX - m.ox) / m.s;
                const size = SHAPES[this.currentShapeIndex].size;
                this.dropX = Math.max(size + 10, Math.min(this.worldW - size - 10, x));

                // current-shapeëŠ” transformìœ¼ë¡œ ì´ë™(ë ˆì´ì•„ì›ƒ ë¹„ìš©â†“)
                const el = document.getElementById('current-shape');
                if (el) {
                    const xPx = m.ox + this.dropX * m.s;
                    el.style.transform = `translate3d(${xPx}px,0,0) translateX(-50%)`;
                }
            }

            
            generateNextShape() {
                this.currentShapeIndex = this.nextShapeIndex;
                // ê°™ì€ ë„í˜•ì´ 2ì—°ì†ìœ¼ë¡œ ë‚˜ì˜¤ì§€ ì•Šë„ë¡ ë‹¤ìŒ ë„í˜• ì„ íƒ(ê¸°ë³¸ í’€: 0~3)
                const baseCount = Math.min(4, SHAPES.length);
                let idx = Math.floor(Math.random() * baseCount);
                if (baseCount > 1) {
                    while (idx === this.currentShapeIndex) {
                        idx = Math.floor(Math.random() * baseCount);
                    }
                }
                this.nextShapeIndex = idx;
                this.updatePreview();
                this.resetAutoDropTimer();
            }
            updatePreview() {
                const cur = document.getElementById('current-shape');
                const nxt = document.getElementById('next-shape');
                if (cur) cur.innerHTML = this.createShapeSVG(this.currentShapeIndex);
                if (nxt) nxt.innerHTML = this.createShapeSVG(this.nextShapeIndex, true);
                this.updateCurrentShapeUI();
            }

            

            createShapeSVG(index, size) {
                const shape = SHAPES[index];
                const vs = size*2.4, cx = vs/2, cy = vs/2, r = size;
                const es = Math.max(1.5, size*0.1), eg = size*0.28, ey = cy - size*0.05;
                const my = cy + size*0.25, mw = size*0.25;
                const uid = Math.random().toString(36).substr(2,6);
                return `<svg width="${vs}" height="${vs}" viewBox="0 0 ${vs} ${vs}">
                    <defs><linearGradient id="g${uid}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${this.lightenColor(shape.color,15)}"/>
                        <stop offset="100%" style="stop-color:${this.darkenColor(shape.color,15)}"/>
                    </linearGradient></defs>
                    <path d="${this.getShapePath(shape.type, cx, cy, r)}" fill="url(#g${uid})" stroke="${this.darkenColor(shape.color,15)}" stroke-width="2"/>
                    <ellipse cx="${cx-eg}" cy="${ey}" rx="${es}" ry="${es*1.3}" fill="#2C1810"/>
                    <ellipse cx="${cx-eg-es*0.25}" cy="${ey-es*0.35}" rx="${es*0.35}" ry="${es*0.4}" fill="#fff"/>
                    <ellipse cx="${cx+eg}" cy="${ey}" rx="${es}" ry="${es*1.3}" fill="#2C1810"/>
                    <ellipse cx="${cx+eg-es*0.25}" cy="${ey-es*0.35}" rx="${es*0.35}" ry="${es*0.4}" fill="#fff"/>
                    <path d="M ${cx-mw/2} ${my} Q ${cx} ${my+mw*0.5} ${cx+mw/2} ${my}" fill="none" stroke="#8B4513" stroke-width="${Math.max(1.2,size*0.05)}" stroke-linecap="round"/>
                </svg>`;
            }

            darkenColor(c, p) { const n = parseInt(c.replace('#',''),16), a = Math.round(2.55*p); return `#${(1<<24|Math.max(0,(n>>16)-a)<<16|Math.max(0,((n>>8)&0xFF)-a)<<8|Math.max(0,(n&0xFF)-a)).toString(16).slice(1)}`; }
            lightenColor(c, p) { const n = parseInt(c.replace('#',''),16), a = Math.round(2.55*p); return `#${(1<<24|Math.min(255,(n>>16)+a)<<16|Math.min(255,((n>>8)&0xFF)+a)<<8|Math.min(255,(n&0xFF)+a)).toString(16).slice(1)}`; }

            setExpression(id, expr, dur) { this.expressionTimers.set(id, { type: expr, until: Date.now() + dur }); }

            triggerNearbyReactions(x, y, excludeId) {
                this.bodies.forEach(s => {
                    if (s.id === excludeId) return;
                    const dx = s.body.position.x - x, dy = s.body.position.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 80) {
                        if (dy > 0 && Math.abs(dx) < 40) this.setExpression(s.id, EXPRESSIONS.WORRIED, 1000);
                        else if (dist < 60) this.setExpression(s.id, Math.random() > 0.5 ? EXPRESSIONS.HAPPY : EXPRESSIONS.EXCITED, 800);
                    }
                });
            }

            dropShape(_forced=false) {
                if (!this.canDrop || this.isGameOver) return;
                this.resetAutoDropTimer();
                this.canDrop = false;
                this.sound.playDrop();
                const body = this.createPhysicsBody(this.dropX, 50, this.currentShapeIndex);
                this.bodies.push({ body, shapeIndex: this.currentShapeIndex, id: body.id, hasLanded: false });
                Matter.Composite.add(this.world, body);
                this.triggerNearbyReactions(this.dropX, 150, body.id);
                this.generateNextShape();
                setTimeout(() => this.canDrop = true, 400);
            }

            createPhysicsBody(x, y, shapeIndex) {
                const shape = SHAPES[shapeIndex];
                const size = shape.size;
                const opts = { friction: 0.6, frictionStatic: 0.8, restitution: 0.12, density: 0.0012, label: `shape_${shapeIndex}`, slop: 0.01 };

                let body;
                switch(shape.type) {
                    case 'circle': case 'bigcircle': body = Matter.Bodies.circle(x, y, size, opts); break;
                    case 'triangle': body = Matter.Bodies.polygon(x, y, 3, size, opts); break;
                    case 'isoceles': body = Matter.Bodies.fromVertices(x, y, [[{x:0,y:-size*1.3},{x:size*0.7,y:size*0.7},{x:-size*0.7,y:size*0.7}]], opts); break;
                    case 'square': body = Matter.Bodies.rectangle(x, y, size*1.6, size*1.6, opts); break;
                    case 'rectangle': body = Matter.Bodies.rectangle(x, y, size*2.2, size*1.2, opts); break;
                    case 'diamond': body = Matter.Bodies.fromVertices(x, y, [[{x:0,y:-size},{x:size*0.75,y:0},{x:0,y:size},{x:-size*0.75,y:0}]], opts); break;
                    case 'pentagon': body = Matter.Bodies.polygon(x, y, 5, size, opts); break;
                    case 'hexagon': body = Matter.Bodies.polygon(x, y, 6, size, opts); break;
                    default: body = Matter.Bodies.circle(x, y, size, opts);
                }
                return body || Matter.Bodies.circle(x, y, size, opts);
            }

            createRockBody(x, y) {
                const size = SHAPES[0].size; // 1ë‹¨ê³„ ì› í¬ê¸°
                const opts = { friction: 0.9, frictionStatic: 1.0, restitution: 0.05, density: 0.002, label: 'rock', slop: 0.02 };
                // ê°ì§„ ì§±ëŒ(ë¶ˆê·œì¹™ ë‹¤ê°í˜•)
                const verts = [];
                const sides = 6;
                for (let i = 0; i < sides; i++) {
                    const a = (Math.PI * 2 * i) / sides;
                    const rr = size * (0.75 + Math.random() * 0.35);
                    verts.push({ x: Math.cos(a) * rr, y: Math.sin(a) * rr });
                }
                return Matter.Bodies.fromVertices(x, y, [verts], opts, true);
            }

            dropRocks(n=1) {
                if (this.isGameOver) return;
                const size = SHAPES[0].size;
                for (let i = 0; i < n; i++) {
                    const x = Math.max(size + 10, Math.min(this.width - size - 10, 10 + Math.random() * (this.width - 20)));
                    const rock = this.createRockBody(x, 30);
                    this.bodies.push({ body: rock, shapeIndex: 0, id: rock.id, hasLanded: false, isRock: true });
                    Matter.Composite.add(this.world, rock);
                }
            }

            removeRocksNear(x, y, radius=90) {
                const toRemove = [];
                for (const s of this.bodies) {
                    if (!s.isRock) continue;
                    const dx = s.body.position.x - x;
                    const dy = s.body.position.y - y;
                    if (Math.sqrt(dx*dx + dy*dy) <= radius) toRemove.push(s);
                }
                if (toRemove.length === 0) return;
                for (const s of toRemove) {
                    try { Matter.Composite.remove(this.world, s.body); } catch(e) {}
                    this.expressionTimers.delete(s.id);
                }
                const ids = new Set(toRemove.map(s => s.id));
                this.bodies = this.bodies.filter(s => !ids.has(s.id));
            }

            getNetState() {
                return {
                    w: this.worldW,
                    h: this.worldH,
                    score: this.score,
                    over: this.isGameOver ? 1 : 0,
                    bodies: this.bodies.map(s => ({
                        x: Math.round(s.body.position.x * 10) / 10,
                        y: Math.round(s.body.position.y * 10) / 10,
                        a: Math.round(s.body.angle * 1000) / 1000,
                        i: s.shapeIndex,
                        r: s.isRock ? 1 : 0
                    }))
                };
            }

            handleCollision(bodyA, bodyB) {
                const isFloorA = bodyA.label === 'floor', isFloorB = bodyB.label === 'floor';
                
                if (isFloorA || isFloorB) {
                    const shapeBody = isFloorA ? bodyB : bodyA;
                    const shapeData = this.bodies.find(s => s.body.id === shapeBody.id);
                    if (shapeData && !shapeData.hasLanded) {
                        shapeData.hasLanded = true;
                        this.sound.playLand();
                        this.setExpression(shapeData.id, EXPRESSIONS.SURPRISED, 300);
                    }
                    return;
                }
                
                if (bodyA.isStatic || bodyB.isStatic) return;

                const shapeA = this.bodies.find(s => s.body.id === bodyA.id);
                const shapeB = this.bodies.find(s => s.body.id === bodyB.id);
                if (!shapeA || !shapeB) return;

                // ì§±ëŒì€ í•©ì²´/ì ìˆ˜ ì—†ìŒ (ê³µê°„ë§Œ ì°¨ì§€)
                if (shapeA.isRock || shapeB.isRock) {
                    shapeA.hasLanded = true;
                    shapeB.hasLanded = true;
                    return;
                }
                
                // ë‹¤ë¥¸ ë„í˜•ê³¼ ë¶€ë”ªíˆë©´ 'ìŒ“ì„'ìœ¼ë¡œ ê°„ì£¼(ë°”ë‹¥ ì ‘ì´‰ë§Œìœ¼ë¡œëŠ” ìƒë‹¨ ë„í˜•ì´ ì²´í¬ì—ì„œ ë¹ ì§)
                shapeA.hasLanded = true;
                shapeB.hasLanded = true;

                if (shapeA.shapeIndex !== shapeB.shapeIndex) {
                    if (Math.abs(bodyA.velocity.y) > 1 || Math.abs(bodyB.velocity.y) > 1) {
                        const top = bodyA.position.y < bodyB.position.y ? shapeA : shapeB;
                        const bottom = bodyA.position.y < bodyB.position.y ? shapeB : shapeA;
                        this.setExpression(top.id, EXPRESSIONS.WORRIED, 500);
                        this.setExpression(bottom.id, EXPRESSIONS.SURPRISED, 500);
                    }
                    return;
                }
                
                if (shapeA.shapeIndex >= SHAPES.length - 1) return;

                const pairKey = [bodyA.id, bodyB.id].sort().join('-');
                if (this.mergingPairs.has(pairKey)) return;
                this.mergingPairs.add(pairKey);

                const now = Date.now();
                if (now - this.lastMergeTime < 600) this.comboCount++;
                else this.comboCount = 1;
                this.lastMergeTime = now;

                // ì½¤ë³´ê°€ ëŠê¸°ëŠ” ì‹œì ì— ìµœì¢… ì½¤ë³´ ìˆ˜ë¥¼ ì•Œë¦¼(ì˜¨ë¼ì¸ ê³µê²©ìš©)
                const seq = ++this._comboSeq;
                setTimeout(() => {
                    if (this._comboSeq !== seq) return;
                    try { this.onComboEnd && this.onComboEnd(this.comboCount); } catch(e) {}
                }, 650);

                const newIndex = shapeA.shapeIndex + 1;
                const midX = (bodyA.position.x + bodyB.position.x) / 2;
                const midY = (bodyA.position.y + bodyB.position.y) / 2;

                Matter.Composite.remove(this.world, bodyA);
                Matter.Composite.remove(this.world, bodyB);
                this.bodies = this.bodies.filter(s => s.body.id !== bodyA.id && s.body.id !== bodyB.id);
                this.expressionTimers.delete(bodyA.id);
                this.expressionTimers.delete(bodyB.id);

                const newBody = this.createPhysicsBody(midX, midY, newIndex);
                this.bodies.push({ body: newBody, shapeIndex: newIndex, id: newBody.id, hasLanded: true });
                Matter.Composite.add(this.world, newBody);

                const points = (newIndex + 1) * 10 * (this.comboCount > 1 ? this.comboCount : 1);
                this.score += points;
                this.updateUI();
                
                this.sound.playMerge(newIndex);
                this.showMergeEffect(midX, midY, points);
                this.setExpression(newBody.id, EXPRESSIONS.HAPPY, 1500);
                this.triggerNearbyReactions(midX, midY, newBody.id);
                // ê·¼ì²˜ì—ì„œ í•©ì²´ë˜ë©´ ì§±ëŒë„ ê°™ì´ ì‚¬ë¼ì§
                this.removeRocksNear(midX, midY);
                
                if (this.comboCount >= 2) {
                    this.showComboEffect(midX, midY);
                    this.sound.playCombo(this.comboCount);
                    this.bodies.forEach(s => { if (s.id !== newBody.id) this.setExpression(s.id, EXPRESSIONS.EXCITED, 1000); });
                }

                setTimeout(() => this.mergingPairs.delete(pairKey), 100);
            }

            showMergeEffect(x, y, points) {
                const el = document.createElement('div');
                el.className = 'combo-text';
                el.textContent = `+${points}`;
                el.style.left = x + 'px';
                el.style.top = (y + 50) + 'px';
                this.wrapper.appendChild(el);
                setTimeout(() => el.remove(), 1200);
                this.createBurstEffect(x, y + 50);
            }

            createBurstEffect(x, y) {
                ['#FF6B6B','#FECA57','#48DBFB','#1DD1A1','#FF9FF3'].forEach(c => {
                    const p = document.createElement('div');
                    p.className = 'combo-burst';
                    p.style.cssText = `left:${x}px;top:${y}px;width:12px;height:12px;background:${c};border-radius:50%`;
                    this.wrapper.appendChild(p);
                    setTimeout(() => p.remove(), 500);
                });
            }

            showComboEffect(x, y) {
                const el = document.createElement('div');
                el.className = 'combo-text';
                el.textContent = `ğŸ”¥ COMBO x${this.comboCount}! ğŸ”¥`;
                el.style.cssText = `left:${x}px;top:${y+15}px;font-size:20px;color:#D63031`;
                this.wrapper.appendChild(el);
                setTimeout(() => el.remove(), 1200);
            }

            updateUI() { document.getElementById('score').textContent = this.score; }

            checkGameOver() {
                const dangerY = (typeof this.dangerY === 'number') ? this.dangerY : 40;
                let isOverflowing = false;

                for (const shape of this.bodies) {
                    // ìƒˆë¡œ ë–¨ì–´ëœ¨ë¦° ë„í˜•ì´ ë§‰ ìƒì„±ëœ ìˆœê°„(ìœ„ìª½)ì—ëŠ” ë°”ë¡œ ì˜¤ë²„ê°€ ë‚˜ì§€ ì•Šë„ë¡,
                    // ë‹¤ë¥¸ ë¬¼ì²´ì™€ í•œ ë²ˆì´ë¼ë„ ì ‘ì´‰í•œ ë„í˜•ë§Œ ì²´í¬í•œë‹¤.
                    if (!shape.hasLanded) continue;

                    const topY = (shape.body && shape.body.bounds) ? shape.body.bounds.min.y : (shape.body.position.y - SHAPES[shape.shapeIndex].size);
                    const isSettled =
                        Math.abs(shape.body.velocity.y) < 0.6 &&
                        Math.abs(shape.body.velocity.x) < 0.6 &&
                        Math.abs(shape.body.angularVelocity) < 0.06;

                    if (topY <= dangerY) {
                        isOverflowing = true;
                        this.setExpression(shape.id, EXPRESSIONS.WORRIED, 120);

                        // ì½¤ë³´ ëŒ(ì§±ëŒ) ë‚™í•˜ ë“±ìœ¼ë¡œ ì ê¹ ì„ ì„ ìŠ¤ì¹˜ë©° ì§€ë‚˜ê°ˆ ë•Œ
                        // ê³¼ë„í•˜ê²Œ ê²Œì„ì˜¤ë²„ê°€ ë‚˜ì§€ ì•Šë„ë¡ "ì•ˆì • ìƒíƒœ"ê°€ ì¼ì • í”„ë ˆì„ ì§€ì†ë  ë•Œë§Œ ì¢…ë£Œ
                        if (isSettled) {
                            const prev = this.overflowFrames.get(shape.id) || 0;
                            const next = prev + 1;
                            this.overflowFrames.set(shape.id, next);
                            if (next >= 20) {
                                this.gameOver();
                                return;
                            }
                        } else {
                            this.overflowFrames.set(shape.id, 0);
                        }
                    } else {
                        this.overflowFrames.set(shape.id, 0);
                    }
                }

                document.getElementById('overflow-warning').style.display = isOverflowing ? 'block' : 'none';
            }

            gameOver() {
                this.isGameOver = true;
                this.sound.playGameOver();
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('game-over').classList.add('show');
                document.getElementById('overflow-warning').style.display = 'none';
                try { this.onGameOver && this.onGameOver(); } catch(e) {}
            }

            restart() {
                Matter.Composite.clear(this.world, false, true);
                this.bodies = [];
                this.score = 0;
                this.isGameOver = false;
                this.canDrop = true;
                this.comboCount = 0;
                this.lastMergeTime = 0;
                this.shakeRemaining = 2;
                this.blinkTimers.clear();
                this.expressionTimers.clear();
                this.overflowFrames.clear();
                this.mergingPairs.clear();
                this.setupPhysics();
                this.generateNextShape();
                this.generateNextShape();
                this.updateUI();
                this.updateShakeButton();
                document.getElementById('game-over').classList.remove('show');

                // ì‚¬ìš©ìê°€ ìŒì•…ì„ êº¼ë‘ì§€ ì•Šì•˜ë‹¤ë©´, ì¬ì‹œì‘ ì‹œì—ë„ ìë™ìœ¼ë¡œ ìŒì•… ì¬ìƒ
                if (this.musicEnabled && this.soundInitialized && !this.sound.musicPlaying) {
                    this.sound.startMusic();
                    const musicBtn = document.getElementById('music-btn');
                    if (musicBtn) musicBtn.textContent = 'ğŸ¶';
                }
                try { this.onRestart && this.onRestart(); } catch(e) {}
            }

            render() {
                const ctx = this.ctx;
                const cv = this.canvas;
                const v = this.view || { dpr: 1, scale: 1, ox: 0, oy: 0 };

                // reset & clear in canvas pixel space
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, cv.width, cv.height);

                // world -> canvas transform (ê³ ì • ì›”ë“œ ì¢Œí‘œë¥¼ í™”ë©´ì— ìŠ¤ì¼€ì¼)
                ctx.setTransform(v.dpr * v.scale, 0, 0, v.dpr * v.scale, v.dpr * v.ox, v.dpr * v.oy);

                const now = Date.now();
                this.bodies.forEach(shape => {
                    const body = shape.body;
                    const size = SHAPES[0].size;
                    ctx.save();
                    ctx.translate(body.position.x, body.position.y);
                    ctx.rotate(body.angle);
                    if (shape.isRock) this.drawRock(size, body.id, now);
                    else this.drawShape(shape.shapeIndex, SHAPES[shape.shapeIndex].size, body.id, now);
                    ctx.restore();
                });
            }

            drawRock(size, bodyId, now) {
                // ê°ì´ ì§„ ì§±ëŒ + x_x ì–¼êµ´
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.strokeStyle = '#2d3436';
                this.ctx.lineWidth = Math.max(2, size * 0.12);
                // body verticesë¥¼ ê·¸ëŒ€ë¡œ ê·¸ë¦¬ë©´ ë Œë”ì—ì„œ ì´ë¯¸ rotate/translate í–ˆê¸° ë•Œë¬¸ì— ì›ì  ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸° ì–´ë ¤ì›Œì„œ
                // ê°„ë‹¨í•œ ìœ¡ê°í˜• ëŠë‚Œì˜ ëŒì„ ê·¸ë¦¼
                const r = size * 0.95;
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI * 2 * i) / 6;
                    const rr = r * (0.82 + (i % 2) * 0.12);
                    const x = Math.cos(a) * rr;
                    const y = Math.sin(a) * rr;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // x_x eyes
                const eg = size * 0.33;
                const ey = -size * 0.05;
                this.ctx.strokeStyle = '#1f1f1f';
                this.ctx.lineWidth = Math.max(2, size * 0.12);
                const cross = size * 0.12;

                const drawX = (cx, cy) => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - cross, cy - cross);
                    this.ctx.lineTo(cx + cross, cy + cross);
                    this.ctx.moveTo(cx - cross, cy + cross);
                    this.ctx.lineTo(cx + cross, cy - cross);
                    this.ctx.stroke();
                };
                drawX(-eg, ey);
                drawX(eg, ey);

                // mouth (flat)
                this.ctx.beginPath();
                this.ctx.moveTo(-size * 0.22, size * 0.32);
                this.ctx.lineTo(size * 0.22, size * 0.32);
                this.ctx.stroke();
            }

            drawShape(shapeIndex, size, bodyId, now) {
                const shape = SHAPES[shapeIndex];
                // ì„±ëŠ¥: í”„ë ˆì„ë§ˆë‹¤ ê·¸ë¼ë°ì´ì…˜/ìƒ‰ìƒ ê³„ì‚°ì„ ë°˜ë³µí•˜ì§€ ì•Šë„ë¡ ë‹¨ìˆœ ì±„ìƒ‰ + ìºì‹œ
                if (!shape._dark) shape._dark = this.darkenColor(shape.color, 15);

                this.ctx.fillStyle = shape.color;
                this.ctx.strokeStyle = shape._dark;
                this.ctx.lineWidth = 2;
                
                this.ctx.beginPath();
                this.drawShapePath(shape.type, size);
                this.ctx.fill();
                this.ctx.stroke();
                this.drawFace(size, bodyId, now);
            }

            drawShapePath(type, r) {
                switch(type) {
                    case 'circle': case 'bigcircle': this.ctx.arc(0, 0, r, 0, Math.PI*2); break;
                    case 'triangle': for(let i=0;i<3;i++){const a=(i*120-90)*Math.PI/180;i===0?this.ctx.moveTo(r*Math.cos(a),r*Math.sin(a)):this.ctx.lineTo(r*Math.cos(a),r*Math.sin(a));}this.ctx.closePath();break;
                    case 'isoceles': this.ctx.moveTo(0,-r*1.3);this.ctx.lineTo(r*0.7,r*0.7);this.ctx.lineTo(-r*0.7,r*0.7);this.ctx.closePath();break;
                    case 'square': this.ctx.rect(-r*0.8,-r*0.8,r*1.6,r*1.6);break;
                    case 'rectangle': this.ctx.rect(-r*1.1,-r*0.6,r*2.2,r*1.2);break;
                    case 'diamond': this.ctx.moveTo(0,-r);this.ctx.lineTo(r*0.75,0);this.ctx.lineTo(0,r);this.ctx.lineTo(-r*0.75,0);this.ctx.closePath();break;
                    case 'pentagon': for(let i=0;i<5;i++){const a=(i*72-90)*Math.PI/180;i===0?this.ctx.moveTo(r*Math.cos(a),r*Math.sin(a)):this.ctx.lineTo(r*Math.cos(a),r*Math.sin(a));}this.ctx.closePath();break;
                    case 'hexagon': for(let i=0;i<6;i++){const a=(i*60-90)*Math.PI/180;i===0?this.ctx.moveTo(r*Math.cos(a),r*Math.sin(a)):this.ctx.lineTo(r*Math.cos(a),r*Math.sin(a));}this.ctx.closePath();break;
                }
            }

            drawFace(size, bodyId, now) {
                const es = Math.max(2, size*0.1), eg = size*0.28, ey = -size*0.05;
                const exprData = this.expressionTimers.get(bodyId);
                let expr = EXPRESSIONS.NORMAL;
                if (exprData && now < exprData.until) expr = exprData.type;
                else if (exprData) this.expressionTimers.delete(bodyId);
                
                let isBlink = false;
                if (expr === EXPRESSIONS.NORMAL) {
                    let bt = this.blinkTimers.get(bodyId);
                    if (!bt) { bt = { next: now + 800 + Math.random()*2000 }; this.blinkTimers.set(bodyId, bt); }
                    if (now > bt.next) { if (!bt.blinking) { bt.blinking = true; bt.blinkEnd = now + 100; } }
                    if (bt.blinking) { if (now < bt.blinkEnd) isBlink = true; else { bt.blinking = false; bt.next = now + 1500 + Math.random()*2500; } }
                }
                
                this.ctx.fillStyle = '#2C1810';
                
                if (expr === EXPRESSIONS.HAPPY || expr === EXPRESSIONS.EXCITED) {
                    this.ctx.lineWidth = Math.max(2, size*0.06); this.ctx.strokeStyle = '#2C1810';
                    this.ctx.beginPath(); this.ctx.arc(-eg, ey, es*0.8, Math.PI*0.1, Math.PI*0.9); this.ctx.stroke();
                    this.ctx.beginPath(); this.ctx.arc(eg, ey, es*0.8, Math.PI*0.1, Math.PI*0.9); this.ctx.stroke();
                } else if (expr === EXPRESSIONS.SURPRISED) {
                    this.ctx.beginPath(); this.ctx.arc(-eg, ey, es*1.3, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.arc(eg, ey, es*1.3, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath(); this.ctx.arc(-eg-es*0.3, ey-es*0.4, es*0.4, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.arc(eg-es*0.3, ey-es*0.4, es*0.4, 0, Math.PI*2); this.ctx.fill();
                } else if (expr === EXPRESSIONS.WORRIED) {
                    this.ctx.beginPath(); this.ctx.ellipse(-eg, ey-es*0.2, es, es*0.7, -0.2, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.ellipse(eg, ey-es*0.2, es, es*0.7, 0.2, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath(); this.ctx.arc(-eg-es*0.2, ey-es*0.4, es*0.3, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.arc(eg-es*0.2, ey-es*0.4, es*0.3, 0, Math.PI*2); this.ctx.fill();
                } else {
                    const sy = isBlink ? 0.12 : 1;
                    this.ctx.beginPath(); this.ctx.ellipse(-eg, ey, es, es*1.3*sy, 0, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.ellipse(eg, ey, es, es*1.3*sy, 0, 0, Math.PI*2); this.ctx.fill();
                    if (!isBlink) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.beginPath(); this.ctx.ellipse(-eg-es*0.25, ey-es*0.35, es*0.35, es*0.4, 0, 0, Math.PI*2); this.ctx.fill();
                        this.ctx.beginPath(); this.ctx.ellipse(eg-es*0.25, ey-es*0.35, es*0.35, es*0.4, 0, 0, Math.PI*2); this.ctx.fill();
                    }
                }
                
                const my = size*0.25, mw = size*0.25;
                this.ctx.lineWidth = Math.max(1.5, size*0.05); this.ctx.lineCap = 'round';
                
                if (expr === EXPRESSIONS.HAPPY) {
                    this.ctx.strokeStyle = '#FF6B6B';
                    this.ctx.beginPath(); this.ctx.arc(0, my-mw*0.1, mw*0.7, 0.15, Math.PI-0.15); this.ctx.stroke();
                } else if (expr === EXPRESSIONS.EXCITED) {
                    this.ctx.fillStyle = '#FF6B6B';
                    this.ctx.beginPath(); this.ctx.ellipse(0, my+mw*0.2, mw*0.6, mw*0.5, 0, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.beginPath(); this.ctx.ellipse(0, my+mw*0.3, mw*0.35, mw*0.25, 0, 0, Math.PI*2); this.ctx.fill();
                } else if (expr === EXPRESSIONS.SURPRISED) {
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.beginPath(); this.ctx.arc(0, my+mw*0.2, mw*0.35, 0, Math.PI*2); this.ctx.stroke();
                } else if (expr === EXPRESSIONS.WORRIED) {
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.beginPath(); this.ctx.moveTo(-mw/2, my+mw*0.2); this.ctx.quadraticCurveTo(0, my-mw*0.2, mw/2, my+mw*0.2); this.ctx.stroke();
                } else {
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.beginPath(); this.ctx.moveTo(-mw/2, my); this.ctx.quadraticCurveTo(0, my+mw*0.5, mw/2, my); this.ctx.stroke();
                }
                
                if (expr === EXPRESSIONS.HAPPY || expr === EXPRESSIONS.EXCITED) {
                    this.ctx.fillStyle = 'rgba(255,130,130,0.5)';
                    this.ctx.beginPath(); this.ctx.ellipse(-eg-es*2, ey+es*2.5, es*1.3, es*0.9, 0, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.beginPath(); this.ctx.ellipse(eg+es*2, ey+es*2.5, es*1.3, es*0.9, 0, 0, Math.PI*2); this.ctx.fill();
                }
                if (expr === EXPRESSIONS.WORRIED) {
                    this.ctx.fillStyle = 'rgba(100,180,255,0.7)';
                    this.ctx.beginPath(); this.ctx.ellipse(eg+es*2.5, ey-es, es*0.4, es*0.6, 0, 0, Math.PI*2); this.ctx.fill();
                }
            }

            gameLoop() {
                if (!this.isGameOver) {
                    Matter.Engine.update(this.engine, 1000/60);
                    this.checkGameOver();
                    this.tickAutoDrop();
                }
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new ShapeGame();

            // Autoplay policy:
            // AudioContextëŠ” ì‚¬ìš©ì ì œìŠ¤ì²˜(í´ë¦­/í„°ì¹˜/í‚¤ì…ë ¥) ì´í›„ì—ë§Œ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            // ê·¸ë˜ì„œ ì²« ì…ë ¥ ìˆœê°„ì— ìŒì•…ì„ ìë™ ì‹œì‘í•©ë‹ˆë‹¤(ì½˜ì†” ê²½ê³ /ì—ëŸ¬ ë°©ì§€).
            const startAudioOnce = () => {
                if (game.soundInitialized) return;
                try { game.sound.init(); game.sound.startMusic(); game.soundInitialized = true; } catch(e) {}
            };
            window.addEventListener('pointerdown', startAudioOnce, { once: true, passive: true });
            window.addEventListener('keydown', startAudioOnce, { once: true });

            window.__shapeGame = game;
            window.dispatchEvent(new CustomEvent('shapeGameReady', { detail: { game } }));
        });
    </script>
    <script type="module" src="./js/main.js"></script>
</body>
</html>
